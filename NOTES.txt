Log:
        printing out of control
        err return needs better handling
        time to die "counter", starvation "counter" (how to test time elapsed between death and "death declared")
        ("if a philosopher doesn’t start eating ’time_to_die’ milliseconds after starting his last meal or the beginning of the simulation, it dies")
    --> check time_util, philo_thread && philo_thread_util (and print_state_or_kill)
        1 philosopher case (2 forks) not working
        print only when both forks acquired for clarity
        static bool "a_philo_has_died" on printer function
        "general mutex" specifically for printing to avoid "scrambling or intertwinning"
        time to die "counter", starvation "counter" (how to test time elapsed
        between death and "death declared")

        Preventing dead_lock:
        Even philos take right fork first, odd ones take left one first;
        Priority for taking fork given to thread with the biggest wait time and is not sleeping (so "grab" the mutex right away ??)
        Number of times to eat

        if (2 * time_to_eat > curr_time - last_meal)
            no lock

        LLONG_MAX = 9223372036854775807
        ULLONG_MAX = 18446744073709551615

?:
Mutexes protect forks, get sign
Queue for holding forks?
Any use for return value of thread (2nd param of pthread_join)?
What data do I need to pass to threaded function? mutex/fork, timings, philo num(id), state, ...?
Error handling in threaded function? (3rd loop in main)
if any pthread or gettimeofday ft fails, should I retry?
Should I register initial time once for all or once for each as I create threads?

                            ---------TIME---------
        (long)
        uint64_t    ft_time(void)
            gettimeofday;
            return time.tv_sec * 1000 + time.tv_usec / 1000;

        long seconds = (end.tv_sec - start.tv_sec);
        long micros = ((seconds * 1000000) + end.tv_usec) - (start.tv_usec);
        printf("The elapsed time is %d seconds and %d micros\n", seconds, micros);

        printf("Time taken to count to 10^5 is : %ld micro seconds\n",
        ((end.tv_sec * 1000000 + end.tv_usec) -
        (start.tv_sec * 1000000 + start.tv_usec)));

--> The Mac delay problem:

        (by msessa)
        /**/
        void	ft_sleep(t_timeval start_time, int time_to_sleep_in_us)
        {
            usleep(time_to_sleep_in_us - time_to_sleep_in_us / 10);
            while (ft_delta_tv_in_us(start_time, ft_get_tv())
                <= time_to_sleep_in_us)
                continue ;
        }

        https://www.notion.so/philosophers-VM-c60be9c836084edfbcd9c07e29b429c4
        "The secret is using small delays in a loop to achieve greater precision"
                            ---------TIME---------

    forks:
        // bool	*r_fork;	// N0 can take fork 0 and 1, N1 can take 1 and 2 ... Nphil_num can take fork phil_num and 0 (r_fork being equivalent to corresponding N)
	    // bool	*l_fork;
    How to attribute them: (init ft)
        while (i < philo_num - 1)
            philo[i]->r_fork = params->(.)fork[i]; philo[i]l_fork = params->(.)fork[i + 1];
        philo[i]->l_fork = params->(.)fork[i]; philo[i]->l_fork = params->(.)fork[0];





                                    PTHREADS

pthread_create(pthread data type by ref, attributes, function (pointer) by ref, arguments (void *))
returns 0 in case of success

BASICS:
void    *thread_func(void);

int main()
{
    pthread_t   newthread;

    if (pthread_create(&newthread, NULL, thread_func, NULL)) //newthread will execute thread_func concurrently w/ main until one finished or ...
        return (1);
        ---
    pthread_join(&newthread, NULL); // will wait for other threads to finish
}
   > -------- & -------- <

PASSING ARGUMENTS TO THREADS:
void    *thread_func(void *args)
{
    <data_type> *data = (<data_type> *)args;

    // ... do stuff
}

int main()
{
    pthread_t   newthread;
    <data_type>   arg;

    if (pthread_create(&newthread, NULL, thread_func, &arg)) //
        return (1);
        ---
    pthread_join(&newthread, ...); //
}

GETTING RESULTS FROM THREADS:
void    *thread_func(void *args)
{
    <data_type> *data = (<data_type> *)malloc(sizeof(data_type));
    data = stuff;

}

int main()
{
    pthread_t   newthread;
    <data_type>   *argback;

    if (pthread_create(&newthread, NULL, thread_func, NULL))
        return (1);
        ---
    pthread_join(&newthread, &argback); // last arg being 'void **'
}

MUTEX:
pthread_mutex_t mutex;

if (pthread_mutex_init(&mutex, NULL)) // mutex = OTHREAD_MUTEX_INITIALIZER (??)
    return (1);
    ...
if (pthread_mutex_lock(&mutex)) //
    return (2);
    ...
if (pthread_mutex_unlock(&mutex)) //
    return (3);
    ...
if (pthread_mutex_destroy(&mutex)) //
    return (4);



                                                    --DEBUGGING--
LLDB:
thread list -- lists running threads; '*' points to current thread
t <thread_num> or thread select <thread_num> -- switches to thread <thread_num>
b <breakpoint> thread <thread_num> -- sets breakpoint to thread specified by <thread_num>

FSANITIZE:
-fsanitize=thread (on compilation)

(On *.h file):
#if defined(__has_feature)
#  if __has_feature(thread_sanitizer)
// code that builds only under ThreadSanitizer
#  endif
#endif

DELETED:

[thread.c]
void    ft_eat(t_philo *p)
{
	if (!try_get_fork(p->r_fork))
		return ;
	if (!ft_printmsg(p, "has taken a fork."))
		return ;
	if (!try_get_fork(p->l_fork))
	{
		release_fork(p->r_fork);
		ft_printmsg(p, "has released a fork."); //no need for err checking here
		return ;
	}
	if (!ft_printmsg(p, "has taken a fork."))
		return ;
	p->state = EATING;
	if(!ft_printmsg(p, "is eating."))
		return ;
	p->last_meal = ft_gettime(); // ??
	p->meals_eaten++;
	ft_usleep(p->timings.meal_time);
	// usleep((useconds_t)p->timings.meal_time);
	release_fork(p->r_fork);
	release_fork(p->l_fork);
	// while (!release_fork(p->l_fork) || !release_fork(p->r_fork)) // in case it fails to unlock..?
	// 	continue ;
	ft_printmsg(p, "has released both forks.");
	pthread_mutex_unlock(&p->l_fork->lock); // hate it ...
}

[thread_utils.c]

bool	try_get_fork(t_fork *fork)
/* Need condition in case there's but 1 fork
Not sure if it protects anything outside function (whats the point then if no var??)*/
{
	if (pthread_mutex_lock(&fork->lock))
		return (0);
	if (fork->is_taken)
	{
		if (pthread_mutex_unlock(&fork->lock))
			return (0);
		return (0);
	}
	fork->is_taken = 1;
	if (pthread_mutex_unlock(&fork->lock))
		return (0);
	return (1);
}

bool	release_fork(t_fork *fork)
/*l.:42 if <fork> is the 2nd to be put down
<second_fork> will be 0 after this operation
to avoid any philosopher from claiming to be taking an already holding fork*/
{
	static bool	second_fork;

	if (pthread_mutex_lock(&fork->lock))
		return (0);
	fork->is_taken = 0;
	second_fork ^= 1;
	if (!second_fork)
		return (1);
	if (pthread_mutex_unlock(&fork->lock))
		return (0);
	return (1);
}
