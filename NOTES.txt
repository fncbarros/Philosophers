Log:    More data to init (forks and parameters)
        Need to understand timming logic and application (curr_time)
        Test for 3
        Error handling and printing to stderr
        Considering allocating for an array of threads only but that requires identifying the thread calling the functions
        Priority for taking fork given to thread with the biggest wait time and is not sleeping
        Compile with -fsanitize=thread for checking wrong behaviour
        uint64_t    ft_time() <------------------ft proto for getting timestamps
            gettimeofday
            return time.tv_sec * 1000 + time.tv_usec / 1000

    forks:
        // bool	*r_fork;	// N0 can take fork 0 and 1, N1 can take 1 and 2 ... Nphil_num can take fork phil_num and 0 (r_fork being equivalent to corresponding N)
	    // bool	*l_fork;
    How to attribute them: (init ft)
        while (i < philo_num - 1)
            philo[i]->r_fork = params->(.)fork[i]; philo[i]l_fork = params->(.)fork[i + 1];
        philo[i]->l_fork = params->(.)fork[i]; philo[i]->l_fork = params->(.)fork[0];


?:
Timming with gettimeofday?
Use for pthread_detach?
Queue for holding forks? 
Any use for return value of thread (2nd param of pthread_join)?
Mutex prevents all exclusive threads to execute? No!



                                    PTHREADS

pthread_create(pthread data type by ref, attributes, function (pointer) by ref, arguments (void *))
returns 0 in case of success

BASICS:
void    *thread_func(void);

int main()
{
    pthread_t   newthread;

    if (pthread_create(&newthread, NULL, thread_func, NULL)) //newthread will execute thread_func concurrently w/ main until one finished or ...
        return (1);
        ---     
    pthread_join(&newthread, NULL); // will wait for other threads to finish
}
   > -------- & -------- <

PASSING ARGUMENTS TO THREADS:
void    *thread_func(void *args)
{
    <data_type> *data = (<data_type> *)args;
    
    // ... do stuff
}

int main()
{
    pthread_t   newthread;
    <data_type>   arg;

    if (pthread_create(&newthread, NULL, thread_func, &arg)) //
        return (1);
        ---     
    pthread_join(&newthread, ...); //
}

GETTING RESULTS FROM THREADS:
void    *thread_func(void *args)
{
    <data_type> *data = (<data_type> *)malloc(sizeof(data_type));
    data = stuff;

}

int main()
{
    pthread_t   newthread;
    <data_type>   *argback;

    if (pthread_create(&newthread, NULL, thread_func, NULL))
        return (1);
        ---     
    pthread_join(&newthread, &argback); // last arg being 'void **'
}

MUTEX:
pthread_mutex_t mutex;

if (pthread_mutex_init(&mutex, NULL)) // mutex = OTHREAD_MUTEX_INITIALIZER (??)
    return (1);
    ...
if (pthread_mutex_lock(&mutex)) //
    return (2);
    ...
if (pthread_mutex_unlock(&mutex)) //
    return (3);
    ...
if (pthread_mutex_destroy(&mutex)) //
    return (4);



                                                    --DEBUGGING--
LLDB:
thread list -- lists running threads; '*' points to current thread
t <thread_num> or thread select <thread_num> -- switches to thread <thread_num>
b <breakpoint> thread <thread_num> -- sets breakpoint to thread specified by <thread_num>

FSANITIZE:
-fsanitize=thread (on compilation)