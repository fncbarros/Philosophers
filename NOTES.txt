Log:    "if a philosopher doesn’t start eating ’time_to_die’ milliseconds after starting his last meal or the beginning of the simulation, it dies"
        time_to_die set to zero every time a philosopher finishes eating ?
        Count dead time
        time still wrong I believe (1000000?)
        1 philosopher case (2 forks)
        Priority for taking fork given to thread with the biggest wait time and is not sleeping
        Test for 3
        Error handling and printing to stderr
        if (2 * time_to_eat > curr_time - last_meal)
            no lock

?:
Mutexes protect forks, get sign
Timming with gettimeofday? Dun (is it tho?)
Use for pthread_detach?
Queue for holding forks? 
Any use for return value of thread (2nd param of pthread_join)?
Mutex prevents all exclusive threads to execute? No!
What data do I need to pass to threaded function? mutex/fork, timings, philo num(id), state, ...?
Error handling in threaded function? (3rd loop in main)

                            ---------TIME---------
        (long)
        uint64_t    ft_time(void)
            gettimeofday;
            return time.tv_sec * 1000 + time.tv_usec / 1000;

        long seconds = (end.tv_sec - start.tv_sec);
        long micros = ((seconds * 1000000) + end.tv_usec) - (start.tv_usec);
        printf("The elapsed time is %d seconds and %d micros\n", seconds, micros);

        printf("Time taken to count to 10^5 is : %ld micro seconds\n",
        ((end.tv_sec * 1000000 + end.tv_usec) -
        (start.tv_sec * 1000000 + start.tv_usec)));

        A bit confused...
                            ---------TIME---------

    forks:
        // bool	*r_fork;	// N0 can take fork 0 and 1, N1 can take 1 and 2 ... Nphil_num can take fork phil_num and 0 (r_fork being equivalent to corresponding N)
	    // bool	*l_fork;
    How to attribute them: (init ft)
        while (i < philo_num - 1)
            philo[i]->r_fork = params->(.)fork[i]; philo[i]l_fork = params->(.)fork[i + 1];
        philo[i]->l_fork = params->(.)fork[i]; philo[i]->l_fork = params->(.)fork[0];





                                    PTHREADS

pthread_create(pthread data type by ref, attributes, function (pointer) by ref, arguments (void *))
returns 0 in case of success

BASICS:
void    *thread_func(void);

int main()
{
    pthread_t   newthread;

    if (pthread_create(&newthread, NULL, thread_func, NULL)) //newthread will execute thread_func concurrently w/ main until one finished or ...
        return (1);
        ---     
    pthread_join(&newthread, NULL); // will wait for other threads to finish
}
   > -------- & -------- <

PASSING ARGUMENTS TO THREADS:
void    *thread_func(void *args)
{
    <data_type> *data = (<data_type> *)args;
    
    // ... do stuff
}

int main()
{
    pthread_t   newthread;
    <data_type>   arg;

    if (pthread_create(&newthread, NULL, thread_func, &arg)) //
        return (1);
        ---     
    pthread_join(&newthread, ...); //
}

GETTING RESULTS FROM THREADS:
void    *thread_func(void *args)
{
    <data_type> *data = (<data_type> *)malloc(sizeof(data_type));
    data = stuff;

}

int main()
{
    pthread_t   newthread;
    <data_type>   *argback;

    if (pthread_create(&newthread, NULL, thread_func, NULL))
        return (1);
        ---     
    pthread_join(&newthread, &argback); // last arg being 'void **'
}

MUTEX:
pthread_mutex_t mutex;

if (pthread_mutex_init(&mutex, NULL)) // mutex = OTHREAD_MUTEX_INITIALIZER (??)
    return (1);
    ...
if (pthread_mutex_lock(&mutex)) //
    return (2);
    ...
if (pthread_mutex_unlock(&mutex)) //
    return (3);
    ...
if (pthread_mutex_destroy(&mutex)) //
    return (4);



                                                    --DEBUGGING--
LLDB:
thread list -- lists running threads; '*' points to current thread
t <thread_num> or thread select <thread_num> -- switches to thread <thread_num>
b <breakpoint> thread <thread_num> -- sets breakpoint to thread specified by <thread_num>

FSANITIZE:
-fsanitize=thread (on compilation)